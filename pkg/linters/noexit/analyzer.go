package noexit

import (
	"go/ast"

	"golang.org/x/tools/go/analysis"
)

var Analyzer = &analysis.Analyzer{ // nolint:gochecknoglobals
	Name: "noexit",
	Doc:  "Checks usage os.Exit in the main function",
	URL:  "https://github.com/go-course/pkg/linters/noexit",
	Run:  run,
}

func run(pass *analysis.Pass) (interface{}, error) {
	for _, file := range pass.Files {
		if file.Name.Name != "main" {
			continue
		}

		if len(file.Comments) > 0 && file.Comments[0].Text() == "Code generated by 'go test'. DO NOT EDIT.\n" {
			// Ignore test cache files.
			continue
		}

		for _, decl := range file.Decls {
			fn, ok := decl.(*ast.FuncDecl)
			if ok && fn.Name.Name == "main" {
				findExit(pass, fn, file.Decls)
			}
		}
	}

	return nil, nil // nolint:nilnil
}

func findExit(pass *analysis.Pass, fn *ast.FuncDecl, decls []ast.Decl) {
	ast.Inspect(fn, func(n ast.Node) bool {
		call, ok := n.(*ast.CallExpr)
		if !ok {
			return true
		}

		switch fn := call.Fun.(type) {
		case *ast.SelectorExpr:
			if id, ok := fn.X.(*ast.Ident); ok && id.Name == "os" && fn.Sel.Name == "Exit" {
				report(pass, call)
			}
		case *ast.Ident:
			for _, decl := range decls {
				if decl, ok := decl.(*ast.FuncDecl); ok && decl.Name.Name == fn.Name {
					findExit(pass, decl, decls)
				}
			}
		}

		return true
	})
}

func report(pass *analysis.Pass, call *ast.CallExpr) {
	code, ok := call.Args[0].(*ast.BasicLit)
	if ok && code.Value == "0" {
		pass.Reportf(call.Pos(), "use return instead of stop process with code 0")
	} else {
		pass.Reportf(call.Pos(), "use panic instead of stop process with code %s", code.Value)
	}
}
