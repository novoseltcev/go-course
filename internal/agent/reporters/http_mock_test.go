// Code generated by MockGen. DO NOT EDIT.
// Source: http.go
//
// Generated by this command:
//
//	mockgen -source=http.go -destination=./http_mock_test.go -package=reporters_test -typed
//

// Package reporters_test is a generated GoMock package.
package reporters_test

import (
	reflect "reflect"

	gomock "go.uber.org/mock/gomock"
)

// Mockcompressor is a mock of compressor interface.
type Mockcompressor struct {
	ctrl     *gomock.Controller
	recorder *MockcompressorMockRecorder
	isgomock struct{}
}

// MockcompressorMockRecorder is the mock recorder for Mockcompressor.
type MockcompressorMockRecorder struct {
	mock *Mockcompressor
}

// NewMockcompressor creates a new mock instance.
func NewMockcompressor(ctrl *gomock.Controller) *Mockcompressor {
	mock := &Mockcompressor{ctrl: ctrl}
	mock.recorder = &MockcompressorMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *Mockcompressor) EXPECT() *MockcompressorMockRecorder {
	return m.recorder
}

// Compress mocks base method.
func (m *Mockcompressor) Compress(data []byte) ([]byte, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Compress", data)
	ret0, _ := ret[0].([]byte)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Compress indicates an expected call of Compress.
func (mr *MockcompressorMockRecorder) Compress(data any) *MockcompressorCompressCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Compress", reflect.TypeOf((*Mockcompressor)(nil).Compress), data)
	return &MockcompressorCompressCall{Call: call}
}

// MockcompressorCompressCall wrap *gomock.Call
type MockcompressorCompressCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockcompressorCompressCall) Return(arg0 []byte, arg1 error) *MockcompressorCompressCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockcompressorCompressCall) Do(f func([]byte) ([]byte, error)) *MockcompressorCompressCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockcompressorCompressCall) DoAndReturn(f func([]byte) ([]byte, error)) *MockcompressorCompressCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Mockencryptor is a mock of encryptor interface.
type Mockencryptor struct {
	ctrl     *gomock.Controller
	recorder *MockencryptorMockRecorder
	isgomock struct{}
}

// MockencryptorMockRecorder is the mock recorder for Mockencryptor.
type MockencryptorMockRecorder struct {
	mock *Mockencryptor
}

// NewMockencryptor creates a new mock instance.
func NewMockencryptor(ctrl *gomock.Controller) *Mockencryptor {
	mock := &Mockencryptor{ctrl: ctrl}
	mock.recorder = &MockencryptorMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *Mockencryptor) EXPECT() *MockencryptorMockRecorder {
	return m.recorder
}

// Encrypt mocks base method.
func (m *Mockencryptor) Encrypt(data []byte) ([]byte, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Encrypt", data)
	ret0, _ := ret[0].([]byte)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Encrypt indicates an expected call of Encrypt.
func (mr *MockencryptorMockRecorder) Encrypt(data any) *MockencryptorEncryptCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Encrypt", reflect.TypeOf((*Mockencryptor)(nil).Encrypt), data)
	return &MockencryptorEncryptCall{Call: call}
}

// MockencryptorEncryptCall wrap *gomock.Call
type MockencryptorEncryptCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockencryptorEncryptCall) Return(arg0 []byte, arg1 error) *MockencryptorEncryptCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockencryptorEncryptCall) Do(f func([]byte) ([]byte, error)) *MockencryptorEncryptCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockencryptorEncryptCall) DoAndReturn(f func([]byte) ([]byte, error)) *MockencryptorEncryptCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Mockhasher is a mock of hasher interface.
type Mockhasher struct {
	ctrl     *gomock.Controller
	recorder *MockhasherMockRecorder
	isgomock struct{}
}

// MockhasherMockRecorder is the mock recorder for Mockhasher.
type MockhasherMockRecorder struct {
	mock *Mockhasher
}

// NewMockhasher creates a new mock instance.
func NewMockhasher(ctrl *gomock.Controller) *Mockhasher {
	mock := &Mockhasher{ctrl: ctrl}
	mock.recorder = &MockhasherMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *Mockhasher) EXPECT() *MockhasherMockRecorder {
	return m.recorder
}

// GetHash mocks base method.
func (m *Mockhasher) GetHash(data []byte) ([]byte, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetHash", data)
	ret0, _ := ret[0].([]byte)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetHash indicates an expected call of GetHash.
func (mr *MockhasherMockRecorder) GetHash(data any) *MockhasherGetHashCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetHash", reflect.TypeOf((*Mockhasher)(nil).GetHash), data)
	return &MockhasherGetHashCall{Call: call}
}

// MockhasherGetHashCall wrap *gomock.Call
type MockhasherGetHashCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockhasherGetHashCall) Return(arg0 []byte, arg1 error) *MockhasherGetHashCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockhasherGetHashCall) Do(f func([]byte) ([]byte, error)) *MockhasherGetHashCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockhasherGetHashCall) DoAndReturn(f func([]byte) ([]byte, error)) *MockhasherGetHashCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}
